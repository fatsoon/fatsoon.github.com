[{"title":"在Android中使用Chrome Customtabs","date":"2016-08-17T03:28:53.000Z","path":"2016/08/17/Use-Chrome-Customtabs-In-Android/","text":"前言发现使用Twitter时发现它的webview全都是用chrome打开的，而且是单独的一个tab，并且写着由Chrome提供支持，如图： 从Chrome官网了解到这个叫做Chrome Custom Tabs，它和Chrome App以及WebView的加载速度对比图如下： 用法首先需要在你的项目里添加Custom Tabs Support Library。打开build.gradle并在dependency中添加依赖库，dependencies &#123; ... compile &apos;com.android.support:customtabs:24.1.0&apos;&#125; 打开一个Chrome Custom TabString url = ¨https://paul.kinlan.me/¨;CustomTabsIntent.Builder builder = new CustomTabsIntent.Builder();CustomTabsIntent customTabsIntent = builder.build();customTabsIntent.launchUrl(this, Uri.parse(url)); 设置Toolbar的颜色builder.setToolbarColor(colorInt); 更多用法请参考以下链接 Chrome Custom Tabs官网 适配试验后发现如果手机中没有安装Chrome浏览器是无法使用Chrome Custom Tab的，会跳转到自带浏览器，感觉这种体验是不太好的，所以应当检查是否已安装Chrome，如果没有安装Chrome，就要自己使用WebView打开了。//检查是否安装ChromeString packageName = &quot;com.android.chrome&quot;;Intent browserIntent = new Intent();browserIntent.setPackage(packageName);List&lt;ResolveInfo&gt; activitiesList = getPackageManager().queryIntentActivities( browserIntent, -1);if(activitiesList.size() &gt; 0) &#123; // 使用Chrome Custom Tab打开 String url = &quot;https://paul.kinlan.me/&quot;; CustomTabsIntent.Builder builder = new CustomTabsIntent.Builder(); builder.setToolbarColor(Color.RED); CustomTabsIntent customTabsIntent = builder.build(); customTabsIntent.launchUrl(this, Uri.parse(url));&#125; else &#123; //使用自定义的WebViewActivit打开 startActivity(new Intent(MainActivity.this,WebActivity.class));&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://fatsoon.com/tags/Android/"}]},{"title":"使用命令行管理Android SDK","date":"2016-07-11T08:38:00.000Z","path":"2016/07/11/android-commandline-tools/","text":"使用命令行管理Android SDK查看索引android list sdk --allPackages available for installation or update: 152 1- Android SDK Tools, revision 25.1.7 2- Android SDK Platform-tools, revision 24 3- Android SDK Build-tools, revision 24 4- Android SDK Build-tools, revision 23.0.3 5- Android SDK Build-tools, revision 23.0.2 6- Android SDK Build-tools, revision 23.0.1...... 24- Android SDK Build-tools, revision 18.0.1 (Obsolete) 25- Android SDK Build-tools, revision 17 (Obsolete) 26- Documentation for Android SDK, API 23, revision 1 27- SDK Platform Android N, API 24, revision 1 28- SDK Platform Android 6.0, API 23, revision 3 29- SDK Platform Android 5.1.1, API 22, revision 2...... 135- Sources for Android SDK, API 15, revision 2 136- Sources for Android SDK, API 14, revision 1 (Obsolete) 137- GPU Debugging tools, revision 3.1 138- GPU Debugging tools, revision 1.0.3 139- Android Support Repository, revision 33 140- Android Support Library, revision 23.2.1 (Obsolete)...... 150- Google Play Billing Library, revision 5 151- Android Auto API Simulators, revision 1 152- Google Web Driver, revision 2 安装指定序号android update sdk -u -a -t 1,2,3,4,..,n各参数含义通过android update sdk --help查看 项目中的配置是compileSdkVersion 23buildToolsVersion &quot;23.0.2&quot; 按照1中的列表序号执行如下操作，序号可能有变化，请安实际情况填写序号android update sdk -u -a -t 1,2,5,28,139,140","tags":[{"name":"Android","slug":"Android","permalink":"http://fatsoon.com/tags/Android/"}]},{"title":"jenkins-ios-build","date":"2016-07-07T05:17:19.000Z","path":"2016/07/07/jenkins-ios-build/","text":"Mac系统中使用jenkins配合xcode插件进行iOS打包环境搭建java环境本文所使用的是Java 7，其它版本并没有进行验证，不保证会出现小问题。jdk请自行去oracle下载安装 TomcatTomcat用来做jenkins的容器，本文使用的是Tomcat 7，其它版本没有进行验证。请在Apache Tomcat官网下载zip版 jenkins下载jenkins.war 苹果开发者证书和描述文件把苹果开发者证书导入到keychain中，把描述文件(xxx.mobileprovision)双击安装到xcode中去 部署jenkins 解压Tomcat 将jenkins.war放到Tomcat/webapps中 在Tomcat/config/server.xml中配置tomcat的端口，默认为8080 启动tomcat，执行./Tomcat/bin/startup.sh 网页中输入localhost:8080/jenkins即可访问jenkins主页 配置jenkins安装插件在系统管理-管理插件-可选插件中搜索xcode，选择Xcode integration，点击直接安装 注意：如果可选插件列表为空，说明无法连接到jenkins插件中心。可在高级-升级站点中填写http://mirror.xmission.com/jenkins/updates/update-center.json 创建xcode打包任务创建一个项目新建-构建一个自由风格的软件项目 配置项目项目选项勾选丢弃旧的构建 源码管理选择Subversion 增加构建步骤添加Xcode Xcode构建配置General build settings Target填写要打包的Target Configuration填写Release或Debug或其它自定义的配置 勾选Pack application and build .ipa? .ipa filename pattern填projectname_${SHORT_VERSION}_${VERSION}_SVN${SVN_REVISION} Output directory填/Users/xxx/jenkinsBuild/ios 其它其它均为默认配置 执行项目首次执行项目时，codesign会访问你的钥匙串，选择永久允许即可。 好了，享受一键build吧","tags":[{"name":"iOS","slug":"iOS","permalink":"http://fatsoon.com/tags/iOS/"},{"name":"jenkins","slug":"jenkins","permalink":"http://fatsoon.com/tags/jenkins/"}]},{"title":"jenkins进行iOS自动化打包小记","date":"2016-07-06T03:19:19.000Z","path":"2016/07/06/2016-07-06-jenkins-ios-build-mark/","text":"概述在使用jenkins进行iOS打包时遇到的问题，经过查阅资料解决，在此做个简单总结。 jenkins+iOS的配置详细步骤可参阅夜空繁星-海的IOS使用jenkins进行持续集成2 问题总结 Code Sign error: No matching provisioning profile found: Your build settings specify a provisioning profile with the UUID “efe1c26b-5b3f-45d5-ae1f-0cf42f9da974”, however, no such provisioning profile was found. 出现这个问题的原因就是缺少证书和描述文件。 jenkins不会读取当前用户下的keychain中的证书，所以需要把keychain中的证书复制到系统证书下面； jenkins同样不会读取当前用户下的Provisioning Profiles，需要把当前用户的Provisioning Profiles复制到系统目录下sudo cp /Users/xxx/Library/MobileDevice /Library/MobileDevice [Warning: usage of –preserve-metadata with option “resource-rules” (deprecated in Mac OS X &gt;= 10.10)!Warning: –resource-rules has been deprecated in Mac OS X &gt;= 10.10!……ResourceRules.plist: cannot read resources 出现这个问题，一般是OS X 10.10以上系统，需要在Custom xcodebuild arguments中添加CODE_SIGN_RESOURCE_RULES_PATH=$(SDKROOT)/ResourceRules.plist如果Custom xcodebuild arguments中有多个变量，用英文空格分隔开","tags":[{"name":"iOS","slug":"iOS","permalink":"http://fatsoon.com/tags/iOS/"},{"name":"jenkins","slug":"jenkins","permalink":"http://fatsoon.com/tags/jenkins/"}]},{"title":"PAC文件让iOS用上你的shadowsocks","date":"2015-06-02T06:19:19.000Z","path":"2015/06/02/2015-06-02-pac-file-for-ios/","text":"1、iOS上使用shadowsocks的方式1.1 shadowsocks-iOS AppStore下载 表面看来是个内置浏览器，此内置浏览器可以畅通无阻的上网。如果想让其它应用使用，需要打开iOS设置 -&gt; 无线局域网 -&gt; 已连接的WiFi右侧的\u0005i图标 -&gt; HTTP代理 -&gt; 选择自动。填写http://127.0.0.1:8090/proxy.pac 每隔几分钟，shadowsocks-iOS就会被系统终止，所以pac文件也就失效了，所以每隔几分钟就要重新打开一次shadowsocks-iOS，略蛋疼，没办法，iOS为了安全和良好体验嘛。 1.2 自定义PAC文件 PAC 文件用 JavaScript 编写，必须包含FindProxyForURL(url, host)函数。在访问某个网址时，浏览器会调用FindProxyForURL根据其返回值来决定该如何访问。 函数的说明参见PAC 文件及其调试 把PAC文件写好后放在公网可访问的地方，并将地址填写到HTTP代理中，就可以做到用不断开连接。 2、自定义PAC文件连接shadowsocks2.1 连接电脑上配置好的shadowsocks-client 如果你手机和电脑在同一局域网，可以直接把配置好shadowsocks的电脑的ip地址和端口填写到PAC文件中。缺点是换了网络环境后，ip地址会变，变了就要改PAC文件，略麻烦。 2.2 连接你的shadowsocks服务器如果你有自己的shadowsocks服务器，那么你可以直接把服务器ip和端口写在PAC文件中，前提是服务器中要同时安装ssserver和sslocal，并且把sslocal的配置文件中的local_address设为0.0.0.0，否则外网无法连接sslocal， 具体服务器配置文件如下，仅供参考： &#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:8388, &quot;local_address&quot;: &quot;0.0.0.0&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;mypassword&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false&#125; PAC文件这样写：&#123; function FindProxyForURL(url, host) &#123; //将ip和端口替换为&#123;你的服务器ip&#125;:&#123;上面的local_port&#125; return &quot;SOCKS5 123.431.111.77:1080; SOCKS 123.431.111.77:1080&quot;; &#125;&#125; 这样就实现了全局代理，如果想进行过滤，你需要做的就是研究PAC Functions并自行过滤国内地址。 2.3 配好了PAC文件却连不上服务器？ 确保PAC文件可以访问 确保服务器已经打开了’local_port’这个端口 使用tennet验证’local_port’是否可访问telnet 123.431.111.77 1080 3、参考内容 PAC 文件及其调试 shadowsocks-iOS","tags":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://fatsoon.com/tags/shadowsocks/"}]},{"title":"Android中使用AlarmManager执行定时任务","date":"2015-03-19T02:19:19.000Z","path":"2015/03/19/2015-03-19-android-alarmmanager/","text":"1. 概述当你的应用需要使用类似闹钟功能的时候，可以用AlarmManager来实现。 2. 原理 AlarmManager是系统的闹铃管理器，可以给它添加或删除一个闹铃，并给这个闹铃提供一个广播接收器，当时间到达的时候，它就会给那个广播接收器发送广播，我们就可以在广播接收器的onReceive方法中做自己的事情。 3. 代码演示创建一个广播接收器：/** * Created by fanshuo on 15/3/18. */public class MyAlarmReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent) &#123; System.out.println(&quot;MyAlarmReceiver...&quot;); &#125;&#125; 添加一个定时提醒AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);Intent intent = new Intent(context, MyAlarmReceiver.class);PendingIntent sender = PendingIntent.getBroadcast(context, 1, intent, PendingIntent.FLAG_UPDATE_CURRENT);Calendar calendar = Calendar.getInstance();calendar.set(Calendar.HOUR_OF_DAY, 8);calendar.set(Calendar.MINUTE, 15);calendar.set(Calendar.SECOND, 0);calendar.set(Calendar.MILLISECOND, 0);long triggerTime = calendar.getTimeInMillis();am.setRepeating(AlarmManager.RTC_WAKEUP, triggerTime, INTERVAL, sender); setRepeating方法有四个参数，含义如下： type:闹钟类型，有四个可选值 ELAPSED_REALTIME：以手机开机的时间为基准 ELAPSED_REALTIME_WAKEUP：以手机开机的时间为基准，并且可以在休眠时发出广播 RTC：以UTC标准时间为基准 RTC_WAKEUP：以UTC标准时间为基准，并且可以在休眠时发出广播 triggerAtTime：第一次启动的时间，单位是毫秒。如果当前时间超过了triggerTime，就会立即启动这个定时提醒。此时应该设置为triggerTime + INTERVAL，即：首次启动时间 + 循环间隔时间，也就是从下个循环开始启动。 如果type是前两种，就需要提前算好开机后多久启动，如果超过了设定的时间会立即启动； 如果type是后两种，需要设置一个标准时间的毫秒数。 interval：循环启动的间隔时间，单位是毫秒。也就是第一次启动之后，每隔多长时间启动一次。 operation：一个PendingIntent对象。这里用来封装BroadcastReceiver。 删除一个定时提醒Intent intent = new Intent(context, MyAlarmReceiver.class);PendingIntent sender = PendingIntent.getBroadcast(context, 1, intent, PendingIntent.FLAG_CANCEL_CURRENT);//第二个参数必须和创建时的保持一致AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);am.cancel(sender);","tags":[{"name":"Android","slug":"Android","permalink":"http://fatsoon.com/tags/Android/"}]},{"title":"ubuntu上使用shadowsocks + polipo配置socks5和http代理","date":"2015-02-10T23:19:19.000Z","path":"2015/02/11/2015-02-11-shadowsocks-polipo/","text":"shadowsocks安装shadowsocks apt-get install python-pippip install shadowsocks 创建配置文件，ubuntu14.04以上可以使用fast_open &#123; &quot;server&quot;:&quot;my_server_ip&quot;, &quot;server_port&quot;:8388, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;mypassword&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false&#125; 启动shadowsocks服务器端，shadowsocks最新版现在已经支持后台运行 ssserver -c /etc/shadowsocks.json -d start 启动shadowsocks客户端，这里需要指定一个pid file和log file 否则会和ssserver的冲突 sslocal -c /etc/shadowsocks.json -d start --pid-file /tmp/sslocal.pid --log-file /tmp/sslocal.log polipo安装polipo apt-get install polipo 修改配置文件/etc/polipo/config proxyAddress = &quot;0.0.0.0&quot;socksParentProxy = &quot;127.0.0.1:1080&quot;socksProxyType = socks5chunkHighMark = 50331648objectHighMark = 16384serverMaxSlots = 64serverSlots = 16serverSlots1 = 32 重启polipo： /etc/init.d/polipo restart 验证是否正常工作： export http_proxy=&quot;http://127.0.0.1:8123/&quot;curl ifconfig.me 如果正常，会打印出vps的地址","tags":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://fatsoon.com/tags/shadowsocks/"}]},{"title":"使用AppCompat库适配Material Design","date":"2015-02-09T11:49:34.000Z","path":"2015/02/09/2015-02-09-material-design-compat/","text":"Material Design出来很长时间了，你的App为它做适配了吗，其实很简单。 需要用到的库 com.android.support:appcompat-v7 操作步骤1、创建一个主题样式首先定义一个主题名称，然后从Theme.AppCompat继承，然后修改它的三个颜色属性，请看代码： &lt;resources&gt; &lt;!-- 从Theme.AppCompat继承 --&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat&quot;&gt; &lt;!-- 设置颜色--&gt; &lt;!-- ActionBar会取这个颜色 --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/primary&lt;/item&gt; &lt;!-- 状态栏会取这个颜色 --&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/primary_dark&lt;/item&gt; &lt;!-- 单选按钮、输入框等UI控件会取这个颜色 --&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/accent&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 2、替换应用的主题如果你原来使用的自定义主题，需要把parent设置成AppTheme，如果没有使用自定义主题，请直接使用AppTheme主题。 &lt;application android:icon=&quot;@drawable/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/AppTheme&quot; &gt; ......&lt;/application&gt; 3、其它其它的点击效果和特性appcompat会为你做啦。","tags":[{"name":"Android","slug":"Android","permalink":"http://fatsoon.com/tags/Android/"}]},{"title":"Android中的clipToPadding（给ScrollView加padding）","date":"2015-01-20T16:49:34.000Z","path":"2015/01/21/2015-01-21-clip-to-padding/","text":"今天想要实现这样的效果，给ScrollView加paddingTop，并且滑动的时候能滑动到paddingTop所占的区域,发现直接设置paddingTop是不行的，滑动的时候，内容部分会被paddingTop盖住，需要加这样的属性，android:clipToPadding=&quot;false&quot; XML代码&lt;ScrollView android:id=&quot;@+id/scrollview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:clipToPadding=&quot;false&quot; android:paddingTop=&quot;180dp&quot; android:scrollbarSize=&quot;2.0dp&quot; android:scrollbarThumbVertical=&quot;@drawable/scrollbar_detail&quot;&gt;&lt;/ScrollView&gt; ScrollView充满真个屏幕，上面是padding 滑动后可覆盖padding区域","tags":[{"name":"Android","slug":"Android","permalink":"http://fatsoon.com/tags/Android/"}]},{"title":"Android版微信SDK混淆问题（万恶的al.class）","date":"2015-01-14T06:57:00.000Z","path":"2015/01/14/2015-01-14-weixin-proguard/","text":"微信新版Android SDK在混淆打包时报错， (Can&apos;t process class [com/tencent/wxop/stat/al.class] (Unknown verification type [95] in stack map frame)) 首先查到的是vase同学的文章 APP集成了微信分享功能，但是打包时出现错误，仔细检查了proguard配置，感觉配置正确，深表微信sdk自身问题；跑官方找反馈链接未果，只好自己上网查。 ProGuard官网bug反馈中有记载同类错误，有人给出解决方案，将ClassConstants.java中StackMapTable属性改为dummy，重新编译即可。 另外在CSDN上发现有好心人前几天已遇到类似问题，并已将ProGuard编译好，那我们就省事了，拿来直接用好了。经测试可用，感谢Gavin_Mirror同学的无私奉献！ 从vase同学那里下载了jar包后发现会报这个错误java.lang.UnsupportedClassVersionError: proguard/ant/ProGuardTask : Unsupported major.minor version 51.0，搜索以后怀疑是jdk版本的问题，有可能是上面那位同学使用jdk7打包，而我的打包环境是jdk6，所以马上去更新jdk版本，然后就成功了。 解决问题的关键就是：使用4-11版本的已修改ATTR_StackMapTable = &quot;dummy&quot;;的proguard.jar，并且保证打包环境的jdk是最新版本的。","tags":[{"name":"微信sdk","slug":"微信sdk","permalink":"http://fatsoon.com/tags/微信sdk/"}]},{"title":"从Ghost转移到Jekyll","date":"2015-01-13T07:20:34.000Z","path":"2015/01/13/2015-01-13-welcome-to-jekyll/","text":"博客从最开始的CSDN，再到Ghost，再到Jekyll，为什么呢？Ghost总感觉不是自己的，受制于他人，虽然开源，但是还是喜欢Jekyll这种书写方式，目前样式比较simple，慢慢来嘛。 来吧Jekyll，再战十年！","tags":[]},{"title":"使用rsync转移VPS","date":"2014-12-19T14:10:34.000Z","path":"2014/12/19/2014-12-19-change-vps/","text":"现已成功将本博客从DigitalOcean转移到bandwagonhost 原因： DigitalOcean的速度感觉越来越慢 bandwagonhost便宜，9.9美元/年，5G、128M RAM、500G带宽 使用的是linux中的rsync命令。 举个栗子： rsync -vzrtopg –progress -e ssh –delete /etc/supervisor/* /etc/supervisor","tags":[]},{"title":"新浪微博封杀的API","date":"2014-08-02T14:20:34.000Z","path":"2014/08/02/2014-08-02-sinaweibo-api/","text":"最近调用新浪微博API时发现一些接口并没有按照文档说明进行返回数据，而是被加了限制，文档中没有做出说明。 friendships/friends 新浪的通知：“为进一步保护用户数据，即日起微博开放平台将对用户关系读取类接口进行升级，各接口最多返回指定用户关注数/粉丝数30%的数据。本次调整涉及所有获取粉丝或粉丝id、关注列表或关注id列表接口。”","tags":[{"name":"微博sdk","slug":"微博sdk","permalink":"http://fatsoon.com/tags/微博sdk/"}]},{"title":"MonkeyRunner使用入门","date":"2014-07-27T15:20:00.000Z","path":"2014/07/27/2014-07-27-use-monkey-runner/","text":"monkeyrunner是Android SDK中的一个命令（./sdk根目录/tools），它可以执行事先编写好的Python脚本向手机发送操作指令。 monkeyrunner提供以下三个类来进行手机指令的相关操作： MonkeyDivice MonkeyImage MonkeyRunner MonkeyDivice主要负责向手机发送指令 MonkeyImage可以进行截屏，并比较两幅截图的相似度。 MonkeyRunner控制本次测试任务 简单Demo(test.py)如下：#coding=utf-8from com.android.monkeyrunner import MonkeyRunner,MonkeyDevice,MonkeyImage#等待手机连接device = MonkeyRunner.waitForConnection()MonkeyRunner.sleep(1) #coding=utf-8from com.android.monkeyrunner import MonkeyRunner,MonkeyDevice,MonkeyImage#等待手机连接device = MonkeyRunner.waitForConnection()MonkeyRunner.sleep(1)#运行程序的次数count = 0while True: count += 1 #启动待测程序的主activity device.startActivity(component=&apos;com.fatsoon.android.demo/com.fatsoon.android.demo.WelcomeActivity&apos;) #打印循环的次数 print(&quot;count = &quot; + str(count)) #等待10秒 MonkeyRunner.sleep(10) #开始发送指令，按下返回键并松开 device.press(&apos;KEYCODE_BACK &apos;,&apos;DOWN_AND_UP&apos;) MonkeyRunner.sleep(1) 运行这个脚本： 进入sdk根目录/tools目录，在此目录创建上面的test.py，然后在此目录打开终端或命令行，执行monkeyrunner test.py就可以了，例如windows下可以这样执行： D:\\adt-bundle-windows-x86_64-20140321\\sdk\\tools&gt;monkeyrunner test.py 如有错误，欢迎指正。","tags":[{"name":"MonkeyRunner","slug":"MonkeyRunner","permalink":"http://fatsoon.com/tags/MonkeyRunner/"},{"name":"Android","slug":"Android","permalink":"http://fatsoon.com/tags/Android/"}]},{"title":"Django中使用markdown和代码高亮","date":"2014-07-26T07:20:34.000Z","path":"2014/07/26/2014-07-26-use-highlite-in-django/","text":"markdown库简介Python的markdown库流行的有两个，python-markdown和python-markdown2，看名字可以猜出来markdown2要比markdown新，是的，而且Github上的star数量也是markdown2比较多。还有一个重要问题就是，markdown不支持三个反引号包裹的代码块，想要书写代码块，只能缩进一个Tab或者四个空格，非常不方便，所以，我推荐使用python-markdown2。至于这两个哪个更快，我没有做专门测试，但markdown2作者说自己更快，谁知道呢，需要自己做一个详细测试。 python-markdown首先需要安装python-markdown库， pip install markdown 在你的代码中这样使用： import markdownmd = markdown.Markdown()html = md.convert(&quot;# 一级标题&quot;) python-markdown2首先需要安装python-markdown2库， pip install markdown2 在你的代码中这样使用： import markdown2html = markdown2.markdown(&quot;# 一级标题&quot;) 这时候如果插入代码块，是没有高亮效果的，怎么样才能得到高亮效果呢？请继续看下面。 用Pygments美化你的代码块Pygments是Python上的高亮代码块的通用库，支持很多种语言的代码，具体多少种呢？管它呢，反正很好用。说白了它就是一个css主题。python-markdown和python-markdown2都支持Pygments语法高亮，并且它们都依赖于Pygments库。 使用方法 先去选个好看的颜色，http://pygments.org/demo/440022/，在右侧的Use this style:处选择，我是用的monokai 查看这个页面的源代码，把pygments.css弄出来 把pygments.css中的.syntax全部替换成.codehilite，然后在你的网页中引用 还要小改一下你的python代码 python-markdown：html = markdown2.markdown(markdown_text, extras=[&quot;fenced-code-blocks&quot;]) （extras的名字是固定的，和css中的codehilite是对应的） python-markdown2：html = markdown.Markdown(extensions=[&#39;codehilite&#39;]).convert(markdown_text) （extensions的名字是固定的，和css中的codehilite是对应的） 大功告成，赶快去爽一下吧！","tags":[{"name":"Django","slug":"Django","permalink":"http://fatsoon.com/tags/Django/"}]}]